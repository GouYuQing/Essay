### 1.HTTP长轮询，HTTP短轮询，WebSocket

#### （1）http 长轮询

http 长轮询是server 收到请求后如果有数据，立刻响应请求；如果没有数据 就会 停留 一段时间，这段时间内，如果 server 请求的数据到达（如查询数据库或数据的逻辑处理完成），就会立刻响应；如果这段时间过后，还没有数据到达，则以空数据的形式响应http请求；若浏览器收到的数据为空，会再次发送同样的http请求到server；

缺点：server 没有数据到达时，http连接会停留一段时间，这会造成服务器资源浪费；

看个荔枝：

假设有 1000个人停留在某个客户端页面，等待server端的数据更新，那就很有可能服务器这边挂着1000个线程，在不停检测数据是否发生变化，这依然是有问题的；

#### （2）http 短轮询

http 短轮询是 server 收到请求 不管是否有数据到达都直接响应http 请求；如果浏览器收到的数据为空，则隔一段时间，浏览器又会发送相同的http请求到server 以获取数据响应；

缺点：消息交互的实时性较低（server端到浏览器端的数据反馈效率低）；

#### （3）http 长轮询 和 短轮询的异同
1）相同点：当server 的数据不可达时，基于http长轮询和短轮询 的http请求，都会 停留一段时间；
2）不同点：http长轮询是在服务器端的停留，而http 短轮询是在 浏览器端的停留；
3）性能总结：从这里可以看出，不管是长轮询还是短轮询，都不太适用于客户端数量太多的情况，因为每个服务器所能承载的TCP连接数是有上限的，这种轮询很容易把连接数顶满；

#### （4）WebSocket

WebSocket 是 html5 规范发布的新协议，和 http协议完全是两个不同的概念，或者说基本没关系；WebSocket 协议 和 http协议的唯一联系点在于，WebSocket 协议为了兼容现有浏览器的握手规范而采用了 http协议中的握手规范 以建立WebSocket连接；

WebSocket协议：其客户端与服务器建立的是 持久连接；

WebSocket 解决了 HTTP 的几个难题：

1.（http协议的被动性）：采用 WebSocket 协议后，服务器可以主动推送消息给客户端；而不需要客户端以（长/短）轮询的方式发起http请求到server以获取数据更新反馈；这样一来，客户端只需要经过一次HTTP请求，就可以做到源源不断的信息传送了（在程序设计中，这种设计叫做回调，即：server 端有信息了再来通知client 端，而不是 client 端 每次都傻乎乎地跑去轮询server端 是否有消息更新）；

2.（http协议的无状态性/健忘性）：短轮询是每次http请求前都要建立连接，而长轮询是相邻几次请求前都要建立连接；http请求响应完成后，服务器就会断开连接，且把连接的信息全都忘记了；所以每次建立连接都要重新传输连接上下文（下面有补充），将 client 端的连接上下文来告诉server 端；而 WebSockct只需要一次HTTP 握手，整个通讯过程是建立在一次连接（状态）中的，server 端会一直推送消息更新反馈到客户端，直到客户端关闭请求，这样就无需 客户端为发送消息而建立不必要的 tcp 连接 和 为了建立tcp连接而发送不必要的冗余的连接上下文消息；

![image-20211210103455565](image/image-20211210103455565.png)

### 2.TCP拥塞控制

∑对资源的需求>可用资源

![image-20200901143039547](image/image-20200901143039547.png)

拥塞的标志:

1. 重传计时器超时
2. 接收到三个重复确认

![image-20200901143654676](image/image-20200901143654676.png)

![image-20200901143832571](image/image-20200901143832571.png)

当cnwd（拥塞窗口大小）＜ssthresh（门限阈值），使用慢开始算法
		当cnwd=ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法
		当cnwd＞ssthresh，使用拥塞避免算法

![image-20200901144116110](image/image-20200901144116110.png)

TCP通过在发送数据时设置一个**重传定时器**来监控数据的丢失状态，如果重传定时器溢出时还没收到确认信号，则重传该数据。这就是建立重传机制的原因。
下面解释两个名词：
**RTT(Round Trip Time)：**一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值；
**RTO(Retransmission Time Out)：**重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。
RTT和RTO 的关系是：由于网络波动的不确定性，每个RTT都是动态变化的，所以RTO也应随着RTT动态变化。

### 3.HTTP有哪些字段？

### 

| Header             | 解释                                                         | 示例                                                   |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------ |
| Accept-Ranges      | 表明服务器是否支持指定范围请求及哪种类型的分段请求           | Accept-Ranges: bytes                                   |
| Age                | 从原始服务器到代理缓存形成的估算时间（以秒计，非负）         | Age: 12                                                |
| Allow              | 对某网络资源的有效的请求行为，不允许则返回405                | Allow: GET, HEAD,POST                                  |
| Cache-Control      | 告诉所有的缓存机制是否可以缓存及哪种类型                     | Cache-Control: no-cache(不允许缓存)                    |
| Content-Encoding   | web服务器支持的返回内容压缩编码类型。                        | Content-Encoding: gzip                                 |
| Content-Language   | 响应体的语言                                                 | Content-Language: en,zh                                |
| Content-Length     | 响应体的长度                                                 | Content-Length: 348                                    |
| Content-Location   | 请求资源可替代的备用的另一地址                               | Content-Location: /index.htm                           |
| Content-MD5        | 返回资源的MD5校验值                                          | Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==                  |
| Content-Range      | 在整个返回体中本部分的字节位置                               | Content-Range: bytes 21010-47021/47022                 |
| Content-Type       | 返回内容的MIME类型                                           | Content-Type: text/html; charset=utf-8                 |
| Date               | 原始服务器消息发出的时间                                     | Date: Tue, 15 Nov 2010 08:12:31 GMT                    |
| ETag               | 请求变量的实体标签的当前值                                   | ETag: “737060cd8c284d8af7ad3082f209582d”               |
| Expires            | 响应过期的日期和时间                                         | Expires: Thu, 01 Dec 2010 16:00:00 GMT                 |
| Last-Modified      | 请求资源的最后修改时间                                       | Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT           |
| Location           | 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源    | Location: http://www.zcmhi.com/archives/94.html        |
| Pragma             | 包括实现特定的指令，它可应用到响应链上的任何接收方           | Pragma: no-cache                                       |
| Proxy-Authenticate | 它指出认证方案和可应用到代理的该URL上的参数                  | Proxy-Authenticate: Basic                              |
| refresh            | 应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持） | Refresh: 5; url= http://www.zcmhi.com/archives/94.html |
| Retry-After        | 如果实体暂时不可取，通知客户端在指定时间之后再次尝试         | Retry-After: 120                                       |
| Server             | web服务器软件名称                                            | Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)           |
| Set-Cookie         | 设置Http Cookie                                              | Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1    |
| Trailer            | 指出头域在分块传输编码的尾部存在                             | Trailer: Max-Forwards                                  |
| Transfer-Encoding  | 文件传输编码                                                 | Transfer-Encoding:chunked                              |
| Vary               | 告诉下游代理是使用缓存响应还是从原始服务器请求               | Vary: *                                                |
| Via                | 告知代理客户端响应是通过哪里发送的                           | Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)            |
| Warning            | 警告实体可能存在的问题                                       | Warning: 199 Miscellaneous warning                     |
| WWW-Authenticate   | 表明客户端请求实体应该使用的授权方案                         | WWW-Authenticate: Basic                                |

### 4.HTTP状态码

HTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)：

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

HTTP状态码列表:

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。客户端应继续其请求                                     |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |

### 5.SSL/TSL

![image-20200804104955041](image/image-20200804104955041.png)

不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播

#### （1）HTTP三大风险

（1） **窃听风险**（eavesdropping）：第三方可以获知通信内容。//**加密传播**

（2） **篡改风险**（tampering）：第三方可以修改通信内容。//**校验机制**

（3） **冒充风险**（pretending）：第三方可以冒充他人身份参与通信。//**身份证书**

基本思路：公钥加密（非对称加密），保证公钥不被篡改使用数字证书，为了节约时间（公钥加密计算量太大），使用对称加密

HTTPS： 采用 对称加密 和 非对称加密 结合的方式来保护浏览器和服务端之间的通信安全。

**对称加密算法加密数据+非对称加密算法交换密钥+数字证书验证身份=安全**

（1） 客户端向服务器端索要并验证公钥。

（2） 双方协商生成"对话密钥"。

（3） 双方采用"对话密钥"进行加密通信。

#### （2）HTTPS四次握手

握手阶段：四次握手

（1）客户端（通常是浏览器）先向服务器发出加密通信的请求

携带信息：支持的协议版本TSL1.0、客户端随机数、支持的加密方式、支持的压缩方法

（2）服务器回应

携带信息：确认加密版本、服务器生成的随机数、确认加密方法、服务器证书

（3）客户端回应,验证是否可靠证书

携带信息：随机数（用于服务器公钥加密，防止被窃听）、编码方式改变通知（商定加密方法和密钥发送）、通知握手结束

三个随机数是为了保证密钥的随机性

（4）服务器最后的回应

携带信息：编码改变通知、握手阶段结束

### 6.HTTP GET和POST比较

| GET                                                 | POST                                         |
| --------------------------------------------------- | -------------------------------------------- |
| 请求可被缓存                                        | 不会被缓存                                   |
| 请求保留在浏览器历史记录中                          | 请求不会保留在浏览器历史记录中               |
| 请求可被收藏为书签                                  | 不能被收藏为书签                             |
| 请求有长度限制，浏览器的限制原因，因为URL有长度限制 | 请求对数据长度没有要求                       |
| 请求只应当用于取回数据                              | 可以修改数据，但是其实两者都可以传参改变数据 |

其实无论是url还是header还是body，http都是明文传输，所以都不安全，唯一手段是https

GET产生一个TCP数据包；POST产生两个TCP数据包。

```
（对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。）
```

其实GET和POST没有本质区别，就是发送数据的两种方式