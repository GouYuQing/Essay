## HTML相关优化

## CSS相关优化

### （1）内联首屏关键CSS（Critical CSS）

性能优化重要指标---首次有效绘制，指页面首要内容出现在屏幕上的时间，这一指标影响到用户看到页面所需等待的时间

**内联CSS能够使浏览器开始页面渲染的时间提前**，但是不适用于内联较大的CSS文件。因为初始拥塞窗口存在限制（TCP相关概念，通常是 14.6kB，压缩后大小），如果内联CSS后的文件超出了这一限制，系统就需要在服务器和浏览器之间进行更多次的往返，这样并不能提前页面渲染时间

优点：**渲染首屏内容所需的关键CSS内联到HTML中，加快页面渲染时间**

缺点：不会缓存，每次都会重新下载，但是其实控制在了14.6kb内，不是大问题

### （2）异步加载CSS【减少阻塞】

1.js动态创建样式表link元素，插入到DOM中

```js
// 创建link标签
const myCSS = document.createElement( "link" );
myCSS.rel = "stylesheet";
myCSS.href = "mystyles.css";
// 插入到header的最后位置
document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling );
```

2.将link元素的media属性设置为用用户浏览器不匹配的媒体类型，如`media="print"`，甚至可以是完全不存在的类型`media="noexist"`，如果不使用的媒体类型，优先级会被降低，在不阻塞页面的情况下进行**下载**。

```css
<link rel="stylesheet" href="mystyles.css" media="noexist" onload="this.media='all'">/*在文件加载完成之后，将media的值设为screen或all，从而让浏览器开始解析CSS*/
```

3.通过`rel`属性将`link`元素标记为`alternate`可选样式表，也能实现浏览器异步加载，加载完成之后，将`rel`改回去

```css
<link rel="alternate stylesheet" href="mystyles.css" onload="this.rel='stylesheet'">
```

4.``rel="preload"``这一Web标准指出了如何异步加载资源，包括CSS类资源

```css
<link rel="preload" href="mystyles.css" as="style" onload="this.rel='stylesheet'">/*as是必须的。忽略as属性，或者错误的as属性会使preload等同于XHR请求，浏览器不知道加载的是什么内容，因此此类资源加载优先级会非常低*/
```

后三种方法都是一致的，通过改变某些属性来达到异步加载的但不解析，等加载完成之后再解析

### （3）文件压缩【减少文件体积】

构建工具：webpack，gulp/grunt、rollup等也都支持CSS压缩功能

### （4）去除无用的CSS

CSS文件压缩通常只会去除无用的空格，这样就限制了CSS文件的压缩比例，删除无用代码，精简CSS

1.不同元素的重复代码：提取公共类，减少重复

2.整个页面都没用的CSS代码：删除不再使用的代码

### （5）有选择的使用选择器

**CSS选择器的匹配是从右向左进行的**，如果嵌套层级过多，匹配所花时间会更长

对于`#markdown-content-h3`，`#markdown .content h3`时，浏览器生成渲染树时间更长，得先找到DOM中的h3元素，过滤掉祖先不是.content的，过滤到祖先不是#markdown的

但是现在的浏览器有所优化，这个的差别不明显了

遵循如下观点

1.保持简单，不要嵌套过多复杂的浏览器

2.通配符和属性选择器效率最低，所需匹配的元素最多，尽量少使用

3.**不要使用类选择器和ID选择器修饰元素标签**

4.不要放弃可读性和可维护性

### （6）减少昂贵的属性

**所有需要浏览器进行操作或计算的属性相对而言都需要花费更大的代价**，重绘时会降低浏览器渲染性能

如`box-shadow`/`border-radius`/`filter`/透明度/`:nth-child`等

### （7）优化重排和重绘

**减少重排**

避免频繁触发如下操作

1. 改变`font-size`和`font-family`
2. 改变元素的内外边距
3. 通过JS改变CSS类
4. 通过JS获取DOM元素的位置相关属性（如width/height/left等）
5. CSS伪类激活
6. 滚动滚动条或者改变窗口大小

flex具有更好的重排属性，布局时候可以优先考虑

**减少重绘**

如页面滚动时触发的hover事件，可以在滚动的时候禁用hover事件，这样页面在滚动时会更加流畅

### （8）不要使用@import

使用import引用的css只有在引用它的css文件被下载。解析之后，浏览-器才会知道还有另外一个css需要下载，再去下载然后解析构建render tree，就会导致顺序紊乱，回流重绘

使用link就可以了

## JS相关优化

### 1.前端工程化

前端工程化**是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的***为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间\***

**模块化**：大文件拆分成相互依赖的小文件，再进行统一的拼装和加载

JS的模块化：CommonJS、AMD、CMD

css的模块化：SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。

Shadow DOM、CSS in JS和CSS Modules三种解决方案：Vue的scoped style也算是一种局部的CSS

**组件化**（分治思想）：从UI拆分下来的**每个包含模板(HTML)+样式(CSS)+逻辑(JS)功能完备的结构单元**，我们称之为**组件**。

**规范化**：目录结构、编码规范

**自动化**：任何简单机械的重复劳动都应该让机器去完成。自动化工具完成  

### 2.列举3种减少页面加载（感知或实际加载时间）的方法。

1、**减少http请求（合并文件、合并图片）**

2、**优化图片文件，减小其尺寸**，特别是缩略图，一定要按尺寸生成缩略图然后调用，不要在网页中用resize方法实现，虽然这样看到的图片外形小了，但是其加载的数据量一点也没减少。曾经见过有人在网页中加载的缩略图，其真实尺寸有10M之巨…普通图像、icon也要尽可能压缩后，可以采用web图像保存、减少颜色数等等方法实现。

3、图像格式的选择（GIF：提供的颜色较少，可用在一些对颜色要求不高的地方）

4、 **压缩Javascript、CSS代码：**一般js、css文件中存在大量的空格、换行、注释，这些利于阅读，如果能够压缩掉，将会很有利于网络传输。这方面的工具也有很多，可以在百度里搜索一下关键字“css代码压缩”，或者“js代码压缩”将会发现有很多网站都提供这样的功能，这个压缩比率还是比较高的，一般都有百分五十左右。这个代码压缩对于网页的加载还是很有用的。

5、 **服务器启用gzip压缩功能：**将要传输的文件压缩后传输到客户端再解压，在网络传输 数据量会大幅减小。在服务器上的Apache、Nginx可直接启用，也可用代码直接设置传输文件头，增加gzip的设置，也可从 负载均衡设备直接设置。不过需要留意的是，这个设置会略微增加服务器的负担。服务器性能不是很好的网站，要慎重考虑。

6.标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。 当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。）

7、**网址后面加上“/”**:对服务器而言，不加斜杠服务器会多一次判断的过程，加斜杠就会直接返回网站设置的存放在网站根目录下的默认页面。